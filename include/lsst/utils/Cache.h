#ifndef LSST_UTILS_CACHE_H
#define LSST_UTILS_CACHE_H

#include <vector>
#include <utility>  // std::pair
#include <functional>  // std::equal_to
#include <boost/multi_index_container.hpp>
#include <boost/multi_index/sequenced_index.hpp>
#include <boost/multi_index/hashed_index.hpp>
#include <boost/multi_index/composite_key.hpp>
#include <boost/multi_index/member.hpp>
#include <boost/format.hpp>
#include <boost/functional/hash.hpp>  // boost::hash

#include "lsst/pex/exceptions.h"

namespace lsst {
namespace utils {

/// Cache of most recently used values
template <typename Key, typename Value, typename KeyHash=boost::hash<Key>,
          typename KeyPred=std::equal_to<Key>>
class Cache {
  public:
    /// Ctor
    ///
    /// The maximum number of elements may be zero (default), in which
    /// case the cache is permitted to grow without limit.
    Cache(std::size_t maxElements=0) : _maxElements(maxElements), _container() {}

    // Defaulted stuff
    Cache(Cache const &) = default;
    Cache(Cache &&) = default;
    Cache & operator=(Cache const &) = default;
    Cache & operator=(Cache &&) = default;
    ~Cache() = default;

    /// Lookup or generate a value
    ///
    /// If the key is in the cache, the corresponding value is returned.
    /// Otherwise, a value is generated by the provided function which is
    /// cached and returned. Thus, the (expensive) function only fires if
    /// the corresponding value is not already cached.
    ///
    /// Given the possibility of lambdas, we could have made the required
    /// function signature so that it took no arguments. However, it's
    /// possible the user has some function that produces a value
    /// when given a key, so chose to adopt that signature; any other
    /// signature would likely require use of a lambda always.
    Value operator()(Key const& key, std::function<Value(Key const&)>);

    /// Lookup a value
    ///
    /// The key must be in the cache already, or an
    /// lsst::pex::exceptions::NotFoundError will be raised.
    Value operator[](Key const& key) const;

    /// Add a value to the cache
    void add(Key const& key, Value const& value);

    /// Return the number of values in the cache
    std::size_t size() const { return _container.size(); }

    /// Return all keys in the cache, most recent first
    std::vector<Key> keys() const;

    /// Does the cache contain the key?
    bool contains(Key const& key) const { return _lookup(key).second; }

    /// Return the capacity of the cache
    std::size_t capacity() const { return _maxElements; }

    /// Change the capacity of the cache
    void reserve(std::size_t maxElements) { _maxElements = maxElements; _trim(); }

    /// Empty the cache
    void flush();

  private:

    // Trim the cache to size
    void _trim() {
        if (capacity() == 0) return;  // Allowed to grow without limit
        while (size() > capacity()) {
            _container.template get<Sequence>().pop_back();
        }
    }

    // Element in the multi_index container
    typedef std::pair<Key, Value> Element;

    // Tags for multi_index container
    struct Sequence {};
    struct Hash {};

    // The multi_index container
    typedef boost::multi_index_container<
                Element,
                boost::multi_index::indexed_by<
                    boost::multi_index::sequenced<boost::multi_index::tag<Sequence>>,
                    boost::multi_index::hashed_unique<
                        boost::multi_index::tag<Hash>,
                        boost::multi_index::member<Element, Key, &Element::first>,
                            KeyHash>>> Container;

    // Lookup key in the container
    //
    // Returns the iterator and whether there's anything there.
    //
    // If the key exists, updates the cache to make that key the most recent.
    std::pair<typename Container::template index<Hash>::type::iterator, bool> _lookup(Key const& key) const {
        auto const& hashContainer = _container.template get<Hash>();
        auto it = hashContainer.find(key);
        bool found = (it != hashContainer.end());
        if (found) {
            _container.relocate(_container.template get<Sequence>().begin(),
                                _container.template project<Sequence>(it));
        }
        return std::make_pair(it, found);
    }

    // Add a key-value pair that are not already present
    void _addNew(Key const& key, Value const& value) {
        _container.template get<Sequence>().emplace_front(key, value);
        _trim();
    }

    std::size_t _maxElements;  // Maximum number of elements; 0 means infinite
    mutable Container _container;  // Container of key,value pairs
};

// Definitions

template <typename Key, typename Value, typename KeyHash, typename KeyPred>
Value Cache<Key, Value, KeyHash, KeyPred>::operator()(
    Key const& key,
    std::function<Value(Key const& key)> func
) {
    auto result = _lookup(key);
    if (result.second) {
        return result.first->second;
    }
    Value value = func(key);
    _addNew(key, value);
    return value;
}

template <typename Key, typename Value, typename KeyHash, typename KeyPred>
Value Cache<Key, Value, KeyHash, KeyPred>::operator[](Key const& key) const {
    auto result = _lookup(key);
    if (result.second) {
        return result.first->second;
    }
    throw LSST_EXCEPT(pex::exceptions::NotFoundError,
                      (boost::format("Unable to find key: %s") % key).str());
}

template <typename Key, typename Value, typename KeyHash, typename KeyPred>
void Cache<Key, Value, KeyHash, KeyPred>::add(Key const& key, Value const& value) {
    auto result = _lookup(key);
    if (!result.second) {
        _addNew(key, value);
    }
}

template <typename Key, typename Value, typename KeyHash, typename KeyPred>
std::vector<Key> Cache<Key, Value, KeyHash, KeyPred>::keys() const {
    std::vector<Key> result;
    result.reserve(size());
    for (auto & keyValue : _container.template get<Sequence>()) {
        result.push_back(keyValue.first);
    }
    return result;
}

template <typename Key, typename Value, typename KeyHash, typename KeyPred>
void Cache<Key, Value, KeyHash, KeyPred>::flush() {
    while (size() > 0) {
        _container.template get<Sequence>().pop_back();
    }
}


}} // namespace lsst::utils


#endif // ifndef LSST_UTILS_CACHE_H
